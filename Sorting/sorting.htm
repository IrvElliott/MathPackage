<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>SORTING</title>
</head>

<body>

<p><font size="6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SORTING</font></p>

<p><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Irving B. Elliott</font></p>

<p>There are several varieties of programs to sort information. Numeric sorts
are used to sort arithmetic values, such as the cost figures in a spreadsheet.
These are usually used to sort a set of values that are held in memory.
Normally, a sort program rearranges values from beginning to end such that each
value, except the last,&nbsp; is followed by a value that is equal or larger. An
exception would be a numeric sort that starts with the largest value and ends
with the smallest, like a list of famous baseball players and their batting
averages arranged best to worst.</p>
<p>Alphanumeric sorts are used to sort items alphabetically, like the entries in
a dictionary. Each item of the set to be sorted may consist of one or more lines
of text. All or a part of one line contains a consecutive string of characters
called the &quot;key&quot;. The sorting program sorts the file by converting the
key into numeric form, then sorting the set in the same manner as a numeric
sort. Usually, when each item is rearranged, the key and all other information
in each item is kept together. An example would be a membership file with each
item containing a line having the person's last name, a comma, the first name
and a
middle initial, followed by two lines for an address, then a line for a phone number.
In that example, the sorting key could be the last name followed by a comma and
the first name.</p>
<p>Often, the quantity of information to be sorted is so large that it would not
fit into the computer memory; for example, a New York City telephone book. An
early program for sorting such information was invented when memory was
small and magnetic tapes were used as a form of external memory. It was called
the &quot;Four-Tape Sort&quot; and is described in this document. The principles
used in that sort program could be used to write a sorting program using some type of external
memory other than tapes, such as four or more files on external discs or flash drives. </p>

<p>There are two categories of procedures for sorting sets of numerical or
alphabetical items: one is an &quot;in-memory&quot; sort in which the entire set
of items to be sorted are held in random-access memory and the other is the
&quot;sort-merge&quot; for which the data is so large that it won't fit into the
computer's random-access memory.</p>
<p>IN-MEMORY SORTS</p>
<p>The simplest method of sorting is the &quot;interchange sort&quot;, also
known as the &quot;bubble sort&quot;. It is like the procedure used by army
drill sergeants to arrange a column of soldiers in order of increasing height.
The method is that each soldier who has a person in front of him that is taller
than he is, taps that person on the shoulder then exchanges places with him.
After a all the shuffling is over, the column will be sorted by height. This
procedure is also called the &quot;bubble sort&quot; in that it is like every
bubble in a liquid rising until it is smaller or equal to the neighboring higher
bubbles.</p>
<p>A computer procedure for the method consists of an outer loop that starts by
clearing a flag and an inner loop that scans through the entire data and
performs any necessary interchanges. The flag is set in the inner loop if any
interchange is performed. The inner loop is followed by a check of the flag. If
the flag has not been set, no interchange has been performed during the last
inner loop. If this is the case, the outer loop is terminated because the data
is in sorted order. For the worst case, starting with n items in reverse order,
the number of comparisons are n squared minus n. Bubble sort in simple structured
language is as follows:</p>
<p><img border="0" src="Sorts3.jpg" width="322" height="305"></p>
<p>A better method is the &quot;quick sort&quot;. The process has a stack that
is used to register regions of the data that may not be in sorted order and thus
require processing. Initially, the region from 1 to n is registered, where n is
the total number of items. An outer loop obtains the indices of one such region
from the stack then clears that entry from the stack. Next, two inner loops
split the region into a lo-value area and a high-value area. Each of the
resulting two regions is, if having more than one item, scheduled in the stack.
Thus, the process recursively splits each region into zero, one or two sub-regionss
then processes them, if necessary, until the stack is empty and thus the total
region is in sorted order.</p>
<p>The quick-sort is like a game played on a football field covered with stones
to be sorted. Initially, the region to be sorted (1 through n) is marked on a
schedule board. Next, the following operations are performed repeatedly by two
players until the schedule is empty.&nbsp;</p>
<p>The indices of one region are read from the schedule and the values are
scrubbed from the schedule. A referee picks up a stone from anywhere inside the
indicated region and it is used as a standard. A player on the left-end of the
region is told to walk toward the right over stones that are smaller than the
standard but stop when either the stone in front of him is larger or equal to
the standard or he is face-to-face with the other player. A person on the right
is told to walk to the left over stones that are equal or greater than the
standard but to stop when either the stone in front of him is smaller or he is
face-to-face with the other player. If both players are stopped and there are
two or more stones between them, the referee interchanges the two stones then
the process continues. When both players meet face-to-face, the region region on
the left consists of small items and the region on the right, of large items. If
the left region has more than one item, it is then marked on the schedule board.
The region on the right is treated in the same manner..</p>
<p>When there are no more areas on the schedule, the entire set of stones will
be in sorted order, small to large. For the worst case, the number of
comparisons is n times the log to the base 2 of n. Thus, for the sorting of 256
items in reverse order, the quick sort is about 16 times faster than the bubble
sort.</p>
<p><img border="0" src="Qsort.jpg" width="602" height="560"></p>
<p>LARGER-THAN-MEMORY SORTING</p>
<p>If the set of items to be sorted is larger than the available rapid-access
memory and is thus stored on one or more external storage devices, sorting must
be accomplished by a &quot;sort pass&quot; and one or more &quot;merge
passes&quot;. In years past, the external devices were magnetic tapes. Now, the
devices could be disk files or flash drives. This type of sort is usually used
for sorting alphanumeric data. The following is a simple example that describes
the older method using four magnetic tape units. Other sort-merge configurations
using additional tapes, disk files or flash drives could be created to operate
in a similar manner. As shown in the following diagram, the simplest process
uses four tape units identified as unit 1 through unit 4.&nbsp;</p>
<p>The sort pass produces small, sorted sub-sequences and writes them
alternately on tapes 3 and 4. Initially, one item is read from tape 1 and is
written onto tape 3 to start a sub-sequence. Next, items are read repeatedly
from tape 1. If an item is equal or greater than the previously-written item, it
is also written onto tape 3. If the item is smaller, writing is changed to tape
4 and the item is written as the start of a new sub-sequence. Similar operations
are then performed to write the new sequence onto tape 4, until a small item is
encountered and then the writing is switched back to tape 3. The process
continues in that manner such that the sub-sequences are written alternately to
tapes 3 and 4.</p>
<p><img border="0" src="Sorts1.jpg" width="461" height="125"></p>
<p>An alternate method for the sort pass can be used if there is sufficient
memory space. In it, a block of items is read into memory from tape 1 and is
sorted by an in-memory method. This is done repeatedly and each block is
alternately written onto tape 3 or 4.</p>
<p>Each merge pass is similar but the input items are from two input tapes.
Initially, two blank tapes are placed on units 1 and 2. The first merge pass
reads items from both tape 3 and tape 4, checks them for being larger, equal or
smaller than the previously written item, and writes alternately on tapes 1 and
2. A new sub-sequence is started when both input items are smaller than the
previously-written item.&nbsp; Each merge pass produces longer sub-sequences.
After a few merge passes, all of the items are on one tape in sorted order.</p>
<p><img border="0" src="Sorts2.jpg" width="784" height="327"></p>
<p>A flow chart for the Four Tape Sort is as follows: </p>

<p><img border="0" src="file:///E:/MyData/MathPackage/Sorting/4TapeSmall.jpg" width="689" height="879"></p>
<p>ALPHANUMERIC SORTING</p>
<p>An alphanumeric sort program rearranges items such that they are in
alphabetic order. The term &quot;alphanumeric&quot; means that the alphabet of
the items to be sorted is extended so that it starts with the digits 0 through 9
and then is followed by A through Z and lower-case letters a through z.&nbsp; In
a previous part of this document,&nbsp; a computer program for sorting numeric
values is described as a procedure that compares values arithmetically and
rearranges the values in a &quot;sorting order&quot;. The desired order is such
that each value is equal or greater than the preceding value. A program for
sorting alphanumeric items is similar, but the desired order is such that each
item is in alphabetical order. To accomplish that, the computer also compares
items arithmetically. This is possible because characters are represented in the
computer as numeric values. One representation is called &quot;ASCII&quot;,
meaning <strong>American Standard Code for Information Interchange</strong>.
Some of the numeric ASCII codes are as follows:</p>
<p>SOME ASCII CHARACTER CODES<br>
(in decimal)<br>
<br>
Null&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0<br>
Space&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32<br>
Comma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 44<br>
Period&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 46&nbsp;<br>
0 through 9&nbsp;&nbsp;&nbsp; 48 through 57&nbsp;<br>
A through Z&nbsp;&nbsp; 65 through 90&nbsp;<br>
a through z&nbsp;&nbsp;&nbsp;&nbsp; 97 through 122</p>
<p>SORT KEYS</p>
<p>In a set of items to be sorted, each item can consist of one or more lines
(records) of characters. Each item to be sorted has a &quot;key&quot; that is a
region in the item that is used to compare with similar regions in other items
to determine the sorting order. For example, in file representing the members of
a club, the first line may contain a last-name followed by a comma and the first
name and middle initial, the second and third lines may be the address, the
fourth line could be a phone number and the last line, an e-mail address. The
file would then be sorted&nbsp; by using the last name as the key. Another
example of a key used for sorting mail would be a 5-digit area code key located
at a specific place in each item.</p>
<p>COMPARING KEYS&nbsp;</p>
<p>In describing sorting programs, mathematical terms are used to describe
comparisons between two alphanumeric items. For example, when the key of
character string A is compared to a key of string B, one condition might be
expressed as A&gt;=B, meaning A is greater or equal to B. In a numeric
comparison, this is simple to understand. For an alphanumeric comparison, that
notation means that, in a set of sorted items, item A should be&nbsp; next to B
or farther up the line than B.&nbsp;</p>
<p>CHARACTER-BY-CHARACTER COMPARISON</p>
<p>Note that, for the letters, the codes increase in value from A to Z; thus,
the code values from A to Z are in numerically sorted order and arithmetic
comparisons can be made for determining sorting order.&nbsp;For example, to
compare the following two words, one could use a Compare function as shown
below.&nbsp;</p>
<p>In a numeric sort, the items are arranged such that they are increasing
numeric value. If item A is followed by item B, then we can denote that by
A&lt;=B. In an alphanumeric sort, the expression A&lt;=B has a somewhat
different meaning. If items A and B are character strings, it is more
complicated to compare them. though they may be of different lengths, they are
treated as though they are of equal length. If &nbsp; We use the notation
A&lt;=B , we mean that, in the sorted file, A is followed by B; however, the
items are arranged as in a dictionary, with all the ones that begin with the
letter &quot;a&quot; coming first, then all beginning with the letter
&quot;b&quot;, etc. In the subset &nbsp;beginning with &quot;a&quot;, the items
are sorted in order by the second character, etc. A structured dialog for
comparing alphanumeric items A and B is as follows:</p>
<p><img border="0" src="Compare1.jpg" width="542" height="239"><br>
</p>
<p>For example, if two keys A and B are SMITH and SMYTH, the function determines
that the first two characters of both character strings are the same but the
third of each are different. The Y is of higher code value than the I, so B is
greater than A. In a sort, SMITH should come before SMYTH.</p>
<p>WORD-BY-WORD COMPARISON</p>
<p>A computer memory consists of &quot;words&quot;. Each word consists of a
certain number of &quot;bits&quot;. In the following example, consider a
hypothetical computer with each word having 32 bits and thus capable of holding
four eight-bit characters.&nbsp; Thus, the words SMITH and SMYTH would each be
represented as two words, as follows:</p>
<p>Word1&nbsp;&nbsp; Word2&nbsp;</p>
<p>SMIT&nbsp;&nbsp;&nbsp;&nbsp; H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(The H is followed by 3 blanks)&nbsp;&nbsp;&nbsp;</p>
<p>SMYT&nbsp;&nbsp;&nbsp; H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(The H is also followed by 3 blanks)</p>
<p>If these items were to be compared by using the character-by-character
method, six characters would have to be extracted and three letter comparisons
made before it was discovered that SMYTH was larger than SMITH.</p>
<p>To the computer, the four characters in each word forms a very large value.
Each character has a code value; each 8-bit shift from the rightmost position to
to the left&nbsp; is like a multiplication by 256. Thus, the values of the words
are the following:</p>
<p>SMITH Word1=83*256*256*256+77*256*256+73*256+84 =1397573972</p>
<p>SMITH Word2=72*256*256*256+32*256*256+32*256+32 =1210064928</p>
<p>SMYTH Word1=83*256*256*256+77*256*256+89*256+84 =1397578068</p>
<p>SMYTH Word2=72*256*256*256+32*256*256+32*256+32 =1210064928</p>
<p>By comparing the first word of SMITH numerically with the first word of
SMYTH,&nbsp; one would immediately find the SMYTH is larger. Thus, no characters
need to be extracted and only one comparison is necessary.</p>
<p>SOME PECULIARITIES</p>
<p>Years ago, most computer input was in the form of punched cards. For
alphanumeric data, both cards and magnetic tape used a six-bit character set.
This limited the character set to 64 codes. Because they had to include letters,
digits, punctuation characters and function codes such as tab and carriage
return, only upper-case letters were included. Nowadays, most computer data is
in the ASCII 8-bit code and both upper and lower case letters are allowed. In
most sorting jobs, the input is in both cases. For example, the sorting for a
dictionary. When the sorting is done, the key comparisons should treat the
characters as they are all in one case. A trick can be used to cause this to
happen. If we represent the key word &quot;Smith&quot; in ASCII in two 32-bit
computer words, with three blanks following the letter &quot;h&quot;, the bit
pattern is as shown on the top line of the next example.</p>
<p>Smith words &nbsp;&nbsp;&nbsp; 01010011 01101101 01101001 01110100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
01101000 00100000 00100000 00100000&nbsp;&nbsp; (S m i t h blank blank blank)</p>
<p>mask
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
00100000 00100000 00100000 00100000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
00100000 00100000 00100000 00100000</p>
<p>SMITH words&nbsp; 01010011 01001101 01001001 01010100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
01001000 00100000 00100000 00100000&nbsp;&nbsp; (SMITH blank blank blank)</p>
<p>Note that the ASCII lower and upper case letters each differ by the decimal
value 32, which, in 8-bit binary, is 00100000. For that reason, during a sorting
key compare, one can perform a computer OR operation on the Smith words with a
&quot;mask&quot; as shown in the illustration; thus converting the key to
all-upper-case SMITH.</p>
<p>The masking should only be done during the key comparison. The output of the
sort should have the original lower-case letters.</p>
<p>Another peculiarity about alphanumeric sorting is that digit characters are
treated in the same manner as letters. For example, in a numeric sort, the value
50 will be put before the value 101. I n an alphanumeric sort, &quot;101
Dalamations&quot; would be put before &quot;50 Shades of Gray&quot;.</p>
<p>VARIABLE LENGTH KEYS</p>
<p>For some sorts, the keys in the items vary in length. For example, in a
person-directory file, each&nbsp; key may consist of a last name followed by a
comma, a space, a first name, a space, a middle initial then a period. For this
case, the compare algorithm could be for an indefinite number of characters and
be augmented with a test for a period. The comparison would be stopped when a
period is found. For a dictionary sort, both the 32-masking and detection of a
final blank space could be used. Another way would be to check the key for the
ending character and, if that character is not the rightmost&nbsp; character of
a word, to fill the bits to the right with blanks.</p>
<p>LARGE CHARACTER CODES</p>
<p>In years past, most data was entered via punched cards. The combinations of
holes were limited and the alphanumeric character codes were limited to 0
through 63. Only upper-case letters were allowed. In binary, the values in this
range are 000000 through 111111. For this reason, most computers had words with
a bit-length that was a multiple of six. Any letter of value greater than 31 had
a &quot;1&quot; as the leftmost digit of the six-bit binary value.
Unfortunately. if the left-most word of a sort key started with a character with
a 1 bit in the left position, a one's-complement or twos-complement computer
would interpret the word as negative. For that reason, the compare algorithm had
to complement that bit in each word of the key. A 1 bit would be changed to 00
and a 0, to 1. This would essentially fool the computer so that the words
beginning with 0 were converted into negative values and the ones with a leading
1 became positive. The numeric values of each word changes but the sorting
comparisons are the same.&nbsp;</p>
<p>The reason this had to be done is apparent if one pretends we have a computer
with a three-bit word length and do the conversion, as follows:</p>
<p><img border="0" src="file:///E:/MyData/MathPackage/Sorting/Left-BitChange.jpg" width="505" height="448"></p>
<p>.</p>
<p>&nbsp; </p>

<p>&nbsp; </p>

</body>

</html>
